https://github.com/jwilm/alacritty/pull/776

From a4b322cbd0941158b310897ba62e34dbbbd57607 Mon Sep 17 00:00:00 2001
From: Dan Aloni <alonid@gmail.com>
Date: Fri, 8 Sep 2017 21:03:14 +0300
Subject: [PATCH] Support bitmap fonts

To allow FontConfig to work with Bitmap font, we shall pass the size
we are interested in, and account for the size returned in the font
matching process. This is, because we cannot scale those fonts.

FontConfig will return the closest match, and we take its returned
pixel size back when we are rendering the glyphs.

There's an oddity when call set_char_size in TrueType - we need to
behave as if the DPI is 72. It is due to the following macro:

    #define FT_REQUEST_HEIGHT( req )                                        \
          ( (req)->vertResolution                                           \
              ? ( (req)->height * (FT_Pos)(req)->vertResolution + 36 ) / 72 \
              : (req)->height )

Further work can allow for integer scaling of the largest bitmap
font varient.

Tested with Terminus PCF-type font under Linux.

This addresses issue #582 .
---
 font/src/darwin/mod.rs    |  4 +--
 font/src/ft/list_fonts.rs | 74 ++++++++++++++++++++++++++++++++++++++++++++++-
 font/src/ft/mod.rs        | 68 +++++++++++++++++++++++++++++++------------
 font/src/lib.rs           |  2 +-
 src/renderer/mod.rs       | 16 +++++-----
 5 files changed, 134 insertions(+), 30 deletions(-)

diff --git a/font/src/darwin/mod.rs b/font/src/darwin/mod.rs
index 45423123..644c9b61 100644
--- a/font/src/darwin/mod.rs
+++ b/font/src/darwin/mod.rs
@@ -149,7 +149,7 @@ impl ::Rasterize for Rasterizer {
         Ok(font.metrics())
     }
 
-    fn load_font(&mut self, desc: &FontDesc, size: Size) -> Result<FontKey, Error> {
+    fn load_font(&mut self, desc: &FontDesc, size: Size) -> Result<(FontKey, Size), Error> {
         self.keys
             .get(&(desc.to_owned(), size))
             .map(|k| Ok(*k))
@@ -176,7 +176,7 @@ impl ::Rasterize for Rasterizer {
                 self.fonts.insert(key, font);
                 self.keys.insert((desc.clone(), size), key);
 
-                Ok(key)
+                Ok((key, size))
             })
     }
 
diff --git a/font/src/ft/list_fonts.rs b/font/src/ft/list_fonts.rs
index 18cc5007..5c601e5c 100644
--- a/font/src/ft/list_fonts.rs
+++ b/font/src/ft/list_fonts.rs
@@ -21,12 +21,14 @@ pub mod fc {
 
     use foreign_types::{ForeignType, ForeignTypeRef};
 
-    use libc::{c_char, c_int};
+    use libc::{c_char, c_int, c_double};
     use fontconfig::fontconfig as ffi;
 
     use self::ffi::{FcConfigGetCurrent, FcConfigGetFonts, FcSetSystem, FcSetApplication};
     use self::ffi::{FcPatternGetString, FcPatternCreate, FcPatternAddString};
     use self::ffi::{FcPatternGetInteger, FcPatternAddInteger};
+    use self::ffi::{FcPatternGetDouble, FcPatternAddDouble};
+    use self::ffi::{FcPatternGetBool};
     use self::ffi::{FcObjectSetCreate, FcObjectSetAdd};
     use self::ffi::{FcResultMatch, FcResultNoMatch, FcFontSetList};
     use self::ffi::{FcChar8, FcConfig, FcPattern, FcFontSet, FcObjectSet};
@@ -271,6 +273,54 @@ pub mod fc {
         };
     }
 
+    macro_rules! pattern_get_double {
+        ($($method:ident() => $property:expr),+) => {
+            $(
+                pub fn $method(&self, id: isize) -> Option<f64> {
+                    let mut value = 0 as c_double;
+                    unsafe {
+                        let result = FcPatternGetDouble(
+                            self.as_ptr(),
+                            $property.as_ptr() as *mut c_char,
+                            id as c_int,
+                            &mut value
+                        );
+
+                        if result == FcResultMatch {
+                            Some(value as f64)
+                        } else {
+                            None
+                        }
+                    }
+                }
+            )+
+        };
+    }
+
+    macro_rules! pattern_get_bool {
+        ($($method:ident() => $property:expr),+) => {
+            $(
+                pub fn $method(&self, id: isize) -> Option<bool> {
+                    let mut value = 0 as c_int;
+                    unsafe {
+                        let result = FcPatternGetBool(
+                            self.as_ptr(),
+                            $property.as_ptr() as *mut c_char,
+                            id as c_int,
+                            &mut value
+                        );
+
+                        if result == FcResultMatch {
+                            Some(value as isize != 0)
+                        } else {
+                            None
+                        }
+                    }
+                }
+            )+
+        };
+    }
+
     #[derive(Debug, Copy, Clone)]
     pub enum Slant {
         Italic = FC_SLANT_ITALIC as isize,
@@ -338,6 +388,14 @@ pub mod fc {
             ) == 1
         }
 
+        unsafe fn add_double(&self, object: &[u8], v: f64) -> bool {
+            FcPatternAddDouble(
+                self.as_ptr(),
+                object.as_ptr() as *mut c_char,
+                v as c_double
+            ) == 1
+        }
+
         unsafe fn get_string(&self, object: &[u8], index: isize) -> Option<String> {
             let mut format: *mut FcChar8 = ptr::null_mut();
 
@@ -360,6 +418,12 @@ pub mod fc {
             add_style => b"style\0"
         }
 
+        pub fn set_pixelsize(&mut self, pixelsize: f64) -> bool {
+            unsafe {
+                self.add_double(b"pixelsize\0", pixelsize)
+            }
+        }
+
         pub fn set_slant(&mut self, slant: Slant) -> bool {
             unsafe {
                 self.add_integer(b"slant\0", slant as isize)
@@ -405,6 +469,14 @@ pub mod fc {
             index() => b"index\0"
         }
 
+        pattern_get_double! {
+            pixelsize() => b"pixelsize\0"
+        }
+
+        pattern_get_bool! {
+            scalable() => b"scalable\0"
+        }
+
         pub fn config_subsitute(&mut self, config: &ConfigRef, kind: MatchKind) {
             unsafe {
                 FcConfigSubstitute(config.as_ptr(), self.as_ptr(), kind as u32);
diff --git a/font/src/ft/mod.rs b/font/src/ft/mod.rs
index c0fb5e0b..e6354ea0 100644
--- a/font/src/ft/mod.rs
+++ b/font/src/ft/mod.rs
@@ -24,9 +24,23 @@ mod list_fonts;
 use self::list_fonts::fc;
 use super::{FontDesc, RasterizedGlyph, Metrics, Size, FontKey, GlyphKey, Weight, Slant, Style};
 
+#[derive(Clone)]
+enum Scalability {
+    Scalable,
+    NonScalable,
+}
+
+impl Scalability {
+    fn from_property(value: Option<bool>) -> Self {
+        use self::Scalability::*;
+
+        value.map(|x| if x { Scalable } else { NonScalable } ).unwrap_or(Scalable)
+    }
+}
+
 /// Rasterizes glyphs for a single font face.
 pub struct FreeTypeRasterizer {
-    faces: HashMap<FontKey, Face<'static>>,
+    faces: HashMap<FontKey, (Face<'static>, Scalability)>,
     library: Library,
     keys: HashMap<::std::path::PathBuf, FontKey>,
     dpi_x: u32,
@@ -60,7 +74,7 @@ impl ::Rasterize for FreeTypeRasterizer {
             .get(&key)
             .ok_or(Error::FontNotLoaded)?;
 
-        let size_metrics = face.size_metrics()
+        let size_metrics = face.0.size_metrics()
             .ok_or(Error::MissingSizeMetrics)?;
 
         let width = (size_metrics.max_advance / 64) as f64;
@@ -74,11 +88,11 @@ impl ::Rasterize for FreeTypeRasterizer {
         })
     }
 
-    fn load_font(&mut self, desc: &FontDesc, _size: Size) -> Result<FontKey, Error> {
-        let face = self.get_face(desc)?;
+    fn load_font(&mut self, desc: &FontDesc, size: Size) -> Result<(FontKey, Size), Error> {
+        let (face, size, scalability) = self.get_face(desc, size)?;
         let key = FontKey::next();
-        self.faces.insert(key, face);
-        Ok(key)
+        self.faces.insert(key, (face, scalability));
+        Ok((key, size))
     }
 
     fn get_glyph(&mut self, glyph_key: &GlyphKey) -> Result<RasterizedGlyph, Error> {
@@ -116,15 +130,15 @@ impl IntoFontconfigType for Weight {
 
 impl FreeTypeRasterizer {
     /// Load a font face accoring to `FontDesc`
-    fn get_face(&mut self, desc: &FontDesc) -> Result<Face<'static>, Error> {
+    fn get_face(&mut self, desc: &FontDesc, size: Size) -> Result<(Face<'static>, Size, Scalability), Error> {
         match desc.style {
             Style::Description { slant, weight } => {
                 // Match nearest font
-                self.get_matching_face(&desc, slant, weight)
+                self.get_matching_face(&desc, size, slant, weight)
             }
             Style::Specific(ref style) => {
                 // If a name was specified, try and load specifically that font.
-                self.get_specific_face(&desc, &style)
+                self.get_specific_face(&desc, size, &style)
             }
         }
     }
@@ -132,19 +146,23 @@ impl FreeTypeRasterizer {
     fn get_matching_face(
         &mut self,
         desc: &FontDesc,
+        size: Size,
         slant: Slant,
         weight: Weight
-    ) -> Result<Face<'static>, Error> {
+    ) -> Result<(Face<'static>, Size, Scalability), Error> {
         let mut pattern = fc::Pattern::new();
         pattern.add_family(&desc.name);
         pattern.set_weight(weight.into_fontconfig_type());
         pattern.set_slant(slant.into_fontconfig_type());
+        pattern.set_pixelsize(size.as_f32_pts() as f64);
 
         let font = fc::font_match(fc::Config::get_current(), &mut pattern)
             .ok_or_else(|| Error::MissingFont(desc.to_owned()))?;
+        let ret_size = font.pixelsize(0).map(|x| Size::new(x as f32)).unwrap_or(size);
+        let scalability = Scalability::from_property(font.scalable(0));
 
         if let (Some(path), Some(index)) = (font.file(0), font.index(0)) {
-            return Ok(self.library.new_face(path, index)?);
+            return Ok((self.library.new_face(path, index)?, ret_size, scalability));
         }
 
         Err(Error::MissingFont(desc.to_owned()))
@@ -153,17 +171,22 @@ impl FreeTypeRasterizer {
     fn get_specific_face(
         &mut self,
         desc: &FontDesc,
+        size: Size,
         style: &str
-    ) -> Result<Face<'static>, Error> {
+    ) -> Result<(Face<'static>, Size, Scalability), Error> {
         let mut pattern = fc::Pattern::new();
         pattern.add_family(&desc.name);
         pattern.add_style(style);
+        pattern.set_pixelsize(size.as_f32_pts() as f64);
 
         let font = fc::font_match(fc::Config::get_current(), &mut pattern)
             .ok_or_else(|| Error::MissingFont(desc.to_owned()))?;
+        let ret_size = font.pixelsize(0).map(|x| Size::new(x as f32)).unwrap_or(size);
+        let scalability = Scalability::from_property(font.scalable(0));
+
         if let (Some(path), Some(index)) = (font.file(0), font.index(0)) {
             println!("got font path={:?}", path);
-            Ok(self.library.new_face(path, index)?)
+            Ok((self.library.new_face(path, index)?, ret_size, scalability))
         }
         else {
             Err(Error::MissingFont(desc.to_owned()))
@@ -180,8 +203,16 @@ impl FreeTypeRasterizer {
         let size = glyph_key.size.as_f32_pts() * self.dpr;
         let c = glyph_key.c;
 
-        face.set_char_size(to_freetype_26_6(size), 0, self.dpi_x, self.dpi_y)?;
-        let index = face.get_char_index(c as usize);
+        match face.1 {
+            Scalability::Scalable => {
+                face.0.set_char_size(to_freetype_26_6(size), 0, self.dpi_x, self.dpi_y)
+            }
+            Scalability::NonScalable => {
+                face.0.set_char_size(to_freetype_26_6(size), 0, self.dpi_x * 72 / self.dpi_y, 72)
+            }
+        }?;
+
+        let index = face.0.get_char_index(c as usize);
 
         if index == 0 && have_recursed == false {
             let key = self.load_face_with_glyph(c).unwrap_or(glyph_key.font_key);
@@ -194,8 +225,8 @@ impl FreeTypeRasterizer {
             return self.get_rendered_glyph(&new_glyph_key, true);
         }
 
-        face.load_glyph(index as u32, freetype::face::TARGET_LIGHT)?;
-        let glyph = face.glyph();
+        face.0.load_glyph(index as u32, freetype::face::TARGET_LIGHT)?;
+        let glyph = face.0.glyph();
         glyph.render_glyph(freetype::render_mode::RenderMode::Lcd)?;
 
         unsafe {
@@ -307,7 +338,8 @@ impl FreeTypeRasterizer {
                             debug!("Miss for font {:?}", path);
                             let face = self.library.new_face(&path, index)?;
                             let key = FontKey::next();
-                            self.faces.insert(key, face);
+                            let scalability = Scalability::from_property(font.scalable(0));
+                            self.faces.insert(key, (face, scalability));
                             self.keys.insert(path, key);
                             Ok(key)
                         }
diff --git a/font/src/lib.rs b/font/src/lib.rs
index 4d63c7f3..41807062 100644
--- a/font/src/lib.rs
+++ b/font/src/lib.rs
@@ -235,7 +235,7 @@ pub trait Rasterize {
     fn metrics(&self, FontKey) -> Result<Metrics, Self::Err>;
 
     /// Load the font described by `FontDesc` and `Size`
-    fn load_font(&mut self, &FontDesc, Size) -> Result<FontKey, Self::Err>;
+    fn load_font(&mut self, &FontDesc, Size) -> Result<(FontKey, Size), Self::Err>;
 
     /// Rasterize the glyph described by `GlyphKey`.
     fn get_glyph(&mut self, &GlyphKey) -> Result<RasterizedGlyph, Self::Err>;
diff --git a/src/renderer/mod.rs b/src/renderer/mod.rs
index 0dad716e..44f92db0 100644
--- a/src/renderer/mod.rs
+++ b/src/renderer/mod.rs
@@ -195,38 +195,38 @@ impl GlyphCache {
         // Load regular font
         let regular_desc = make_desc(&font.normal, font::Slant::Normal, font::Weight::Normal);
 
-        let regular = rasterizer
+        let (regular, font_size) = rasterizer
             .load_font(&regular_desc, size)?;
 
         // helper to load a description if it is not the regular_desc
         let load_or_regular = |desc:FontDesc, rasterizer: &mut Rasterizer| {
             if desc == regular_desc {
-                regular
+                (regular, font_size)
             } else {
-                rasterizer.load_font(&desc, size).unwrap_or_else(|_| regular)
+                rasterizer.load_font(&desc, size).unwrap_or_else(|_| (regular, font_size))
             }
         };
 
         // Load bold font
         let bold_desc = make_desc(&font.bold, font::Slant::Normal, font::Weight::Bold);
 
-        let bold = load_or_regular(bold_desc, &mut rasterizer);
+        let (bold, _) = load_or_regular(bold_desc, &mut rasterizer);
 
         // Load italic font
         let italic_desc = make_desc(&font.italic, font::Slant::Italic, font::Weight::Normal);
 
-        let italic = load_or_regular(italic_desc, &mut rasterizer);
+        let (italic, _) = load_or_regular(italic_desc, &mut rasterizer);
 
         // Need to load at least one glyph for the face before calling metrics.
         // The glyph requested here ('m' at the time of writing) has no special
         // meaning.
-        rasterizer.get_glyph(&GlyphKey { font_key: regular, c: 'm', size: font.size() })?;
+        rasterizer.get_glyph(&GlyphKey { font_key: regular, c: 'm', size: font_size })?;
         let metrics = rasterizer.metrics(regular)?;
 
         let mut cache = GlyphCache {
             cache: HashMap::default(),
             rasterizer: rasterizer,
-            font_size: font.size(),
+            font_size: font_size,
             font_key: regular,
             bold_key: bold,
             italic_key: italic,
@@ -240,7 +240,7 @@ impl GlyphCache {
                     cache.get(&GlyphKey {
                         font_key: $font,
                         c: i as char,
-                        size: font.size()
+                        size: font_size,
                     }, loader);
                 }
             }
